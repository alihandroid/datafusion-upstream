/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package datafusion_common;

message ColumnRelation {
  string relation = 1;
}

message Column {
  string name = 1;
  ColumnRelation relation = 2;
}

//Useful for representing an empty enum variant in rust
// E.G. enum example{One, Two(i32)}
// maps to
// message example{
//    oneof{
//        EmptyMessage One = 1;
//        i32 Two = 2;
//   }
//}
message EmptyMessage{}

enum TimeUnit{
  Second = 0;
  Millisecond = 1;
  Microsecond = 2;
  Nanosecond = 3;
}

message Timestamp{
  TimeUnit time_unit = 1;
  string timezone = 2;
}

enum IntervalUnit{
  YearMonth = 0;
  DayTime = 1;
  MonthDayNano = 2;
}

message Decimal{
  reserved 1, 2;
  uint32 precision = 3;
  int32 scale = 4;
}

message List{
  Field field_type = 1;
}

message FixedSizeList{
  Field field_type = 1;
  int32 list_size = 2;
}

message Struct{
  repeated Field sub_field_types = 1;
}

enum UnionMode{
  sparse = 0;
  dense = 1;
}

message Union{
  repeated Field union_types = 1;
  UnionMode union_mode = 2;
  repeated int32 type_ids = 3;
}

message Dictionary{
  ArrowType key = 1;
  ArrowType value = 2;
}

message Map {
  Field field_type = 1;
  bool keys_sorted = 2;
}

// Serialized data type
message ArrowType{
  oneof arrow_type_enum {
    EmptyMessage NONE = 1;     // arrow::Type::NA
    EmptyMessage BOOL = 2;     // arrow::Type::BOOL
    EmptyMessage UINT8 = 3;    // arrow::Type::UINT8
    EmptyMessage INT8 = 4;     // arrow::Type::INT8
    EmptyMessage UINT16 = 5;   // represents arrow::Type fields in src/arrow/type.h
    EmptyMessage INT16 = 6;
    EmptyMessage UINT32 = 7;
    EmptyMessage INT32 = 8;
    EmptyMessage UINT64 = 9;
    EmptyMessage INT64 = 10 ;
    EmptyMessage FLOAT16 = 11 ;
    EmptyMessage FLOAT32 = 12 ;
    EmptyMessage FLOAT64 = 13 ;
    EmptyMessage UTF8 = 14 ;
    EmptyMessage LARGE_UTF8 = 32;
    EmptyMessage BINARY = 15 ;
    int32 FIXED_SIZE_BINARY = 16 ;
    EmptyMessage LARGE_BINARY = 31;
    EmptyMessage DATE32 = 17 ;
    EmptyMessage DATE64 = 18 ;
    TimeUnit DURATION = 19;
    Timestamp TIMESTAMP = 20 ;
    TimeUnit TIME32 = 21 ;
    TimeUnit TIME64 = 22 ;
    IntervalUnit INTERVAL = 23 ;
    Decimal DECIMAL = 24 ;
    List LIST = 25;
    List LARGE_LIST = 26;
    FixedSizeList FIXED_SIZE_LIST = 27;
    Struct STRUCT = 28;
    Union UNION = 29;
    Dictionary DICTIONARY = 30;
    Map MAP = 33;
  }
}

message Field {
  // name of the field
  string name = 1;
  ArrowType arrow_type = 2;
  bool nullable = 3;
  // for complex data types like structs, unions
  repeated Field children = 4;
  map<string, string> metadata = 5;
  int64 dict_id = 6;
  bool dict_ordered = 7;
}

message DfField{
  Field field = 1;
  datafusion_common.ColumnRelation qualifier = 2;
}

message DfSchema {
  repeated DfField columns = 1;
  map<string, string> metadata = 2;
}
